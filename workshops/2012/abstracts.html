<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" media="screen,print" href="lfmtp.css" />
    
    <title>LFMTP 2012</title>
  </head>

  <body>
    <div class="main">

      <div class="shape">
        <div>
          <img src="shapeimage_1.png" />
        </div>
      </div>
      
      <div id="widget0">
        <div class="navbar">
          <div class="navbar-bg">
            <ul class="navbar-list">
              <li class="noncurrent-page"><a href="index.html">Welcome</a></li>
              <li class="noncurrent-page"><a href="submissions.html">Submissions</a></li>
              <li class="noncurrent-page"><a href="committees.html">Committees</a></li>
              <li class="noncurrent-page"><a href="accepted.html">Accepted Papers</a></li>
              <li class="noncurrent-page"><a href="programme.html">Programme</a></li>
              <li class="current-page"><a href="abstracts.html">Abstracts</a></li>
            </ul>
          </div>
        </div>
      </div>

      <div class="header_layer">
        <div class="shape2">
          <div>
            <img src="shapeimage_2.png" />
          </div>
        </div>

        <div class="middlebox">
          <div>
            <div>
              <p class="paragraph_style_1">LFMTP 2012</p>
              <p class="paragraph_style_2">7th International Workshop on</p>
              <p class="paragraph_style_2"><span class="style_1">Logical Frameworks and Meta-languages:</span></p>
              <p class="paragraph_style_3"><span class="style_1">Theory and Practice</span></p>
              <p class="paragraph_style_4">Copenhagen, Denmark - September 9, 2012</p>
            </div>
          </div>
        </div>
      </div>

      <div class="body_layer">
        <div class="body_layer2">
          <div>
            <ul>
              <h1>Invited Talks</h1>

              <a name="Pientka">
                <h2>Beluga<sup>mu</sup>: Programming proofs in context</h2>
		<h3><a href="http://www.cs.mcgill.ca/~bpientka/">Brigitte Pientka</a></h3>

                <p>We extend a general purpose functional language with support for programming with binders and contexts by refining the type system of ML with a restricted form of dependent types where index objects are drawn from contextual LF. This allows programmers to specify formal systems and proofs within the logical framework LF using higher-order abstract syntax and avoids common and tricky routines dealing with variables, such as capture-avoiding substitution and renaming. In addition, programmers can index ML types with contexts and contextual LF objects allowing users to define relations between them.  This leads to a powerful language, Beluga<sup>mu</sup>, which supports manipulating and analyzing contexts and contextual LF objects. To illustrate the elegance and effectiveness of our language, we give elegant and concise programs for closure conversion and normalization by evaluation.</p>
	      </a>

	      <a name="Pouillard">
		<h2>From de Bruijn to nowadays: The evolution of libraries for binding representation</h2>
		<h3><a href="http://nicolaspouillard.fr/">Nicolas Pouillard</a></h3>

		<p>Binding representation: from the early days of de Bruijn indices to approaches using polymorphism in various ways, I will try to present the step by step evolution leading to nowadays techniques. The support for binding structures has been studied both as a language design and as a technique hosted by a language. In this talk I will primarily focus on the latter, i.e. libraries, making use of a single and consistent presentation.</p>
	      </a>

	      <a name="Simmons">
		<h2>A Walk in the Substructural Park</h2>
		<h3><a href="http://www.cs.cmu.edu/~rjsimmon/">Robert J. Simmons</a></h3>

		<p><i>Substructural operational semantics</i> (SSOS) specifications were introduced by Pfenning as a presentation form for the operational semantics of programming languages. SSOS specifications are informed by intuitionistic substructural logics and have the feel of abstract machine specifications. They are characterized by a high degree of modular extensibility - new features can be added without disturbing existing specifications. In particular, specifications can be easily written to be agnostic about the presence of language features that manipulate state, parallelism, and control flow.</p>

		<p>Early work on SSOS explored a number of idioms and styles, some of which differ in the degree of modular extensibility they support. Borrowing from Danvy et al.’s work on the <i>functional correspondence</i>, the <i>logical correspondence</i> connects these various styles by showing how they can be derived from one another by automatic and meaning-preserving transformations on specifications in a logical framework. These transformations set up a taxonomy of existing styles and make it possible to integrate multiple styles within a single specification.</p>

		<p>This talk presents joint work with Frank Pfenning and Ian Zerny.</p>
	      </a>

	      <a name="Weirich">
		<h2>A POPLmark retrospective: Using proof assistants in programming language research</h2>
		<h3><a href="http://www.cis.upenn.edu/~sweirich/">Stephanie Weirich</a></h3>

		<p>More than seven years ago, a group of researchers at Penn and Cambridge issued the POPLmark challenge: a set of challenge problems designed to demonstrate the effectiveness of proof assistants for programming language research. Programming language papers often are accompanied by long technical reports containing the details of the proofs. These proofs exist merely to bolster confidence in the results---they are rarely read closely. Ideally, such proofs should be expressed in the formal logic of a proof assistant. Our vision was a world where all programming language conference papers (such as for POPL) were accompanied by machine-checked appendices.</p>

		<p>In this overview talk, I will revisit the motivation of the POPLmark challenge to reflect on the progress we and others with similar vision have made since the challenge was issued. I will focus on the questions of 'What is the role of a proof assistant in PL research?', 'Did we get where we wanted to go?' and 'Where do we go from here?'</p>
	      </a>

              <h1>Regular Papers</h1>

	      <a name="Momigliano">
		<h2>A supposedly fun thing I may have to do again: A HOAS encoding of Howe's method</h2>
		<h3><a href="http://homepages.inf.ed.ac.uk/amomigl1/">Alberto Momigliano</a></h3>

		<p>We formally verify in Abella that similarity in the call-by-name lambda calculus is a pre-congruence, using Howe's method. This turns out to be a very challenging task for HOAS-based systems, as it entails a demanding combination of inductive and coinductive reasoning on open terms, for which no other existing HOAS-based system is equipped for. We also offer a proof using a version of Abella supplemented with predicate quantification; this  results in a more structured presentation that is largely independent of the operational semantics as well of the chosen notion of (bi)similarity.  While the end result is significantly more succinct and elegant than previous attempts, the exercise highlights some limitations of the two-level approach in general and of Abella in particular.</p>

		<p><a href="http://homepages.inf.ed.ac.uk/amomigl1/Howe/">Source code</a></p>
	      </a>

	      <a name="Martens">
		<h2>LF in LF: Mechanizing the Metatheory of LF in Twelf</h2>
		<h3><a href="http://www.cs.cmu.edu/~cmartens/">Chris Martens</a> and <a href="http://www.cs.cmu.edu/~crary">Karl Crary</a></h3>

		<p>We present a mechanized metatheoretic development of two presentations of LF: the Canonical presentation (in which only beta-short, eta-long terms are well-formed) and the original version based on definitional equivalence. We prove the standard metatheory, i.e. that type checking is decidable and canonical forms exist uniquely. We do so by translating structures from the original formulation to the canonical formulation, establishing that definitional equivalence corresponds to syntactic equivalence of canonical forms. This particular approach represents the first syntactic proof of the metatheory of LF, thus the first that can be mechanized in Twelf. It is also the first proof formally addressing the correspondence between hereditary substitution in Canonical LF and definitional equivalence in the traditional version, justifying the body of recent work that takes Canonical LF as primary.</p>
	      </a>

	      <a name="Honsell">
		<h2>LFP – A Logical Framework with External Predicates</h2>
		<h3><a href="http://users.dimi.uniud.it/~furio.honsell/">Furio Honsell</a>, <a href="http://www.dimi.uniud.it/lenisa">Marina Lenisa</a>, <a href="http://www-sop.inria.fr/mascotte/Luigi.Liquori/">Liquori Luigi</a>, Petar Maksimovic and <a href="http://users.dimi.uniud.it/~ivan.scagnetto/">Ivan Scagnetto</a></h3>

		<p>The LF<sub><em>P</em></sub> Framework is an extension of the Harper-Honsell-Plotkin's Edinburgh Logical Framework LF with <em>external predicates</em>. This is accomplished by defining <em>lock type constructors</em>, which are a sort of <em>diamond-modality constructors</em>, releasing their argument <em>under the condition</em> that a possibly <em>external predicate</em> is satisfied on an appropriate typed judgement. Lock types are defined using the standard pattern of constructive type theory, i.e. via <em>introduction</em>, <em>elimination</em>, and <em>equality rules</em>. Using LF<sub><em>P</em></sub>, one can factor out the complexity of encoding  specific features of logical systems which would otherwise be  awkwardly encoded in LF, e.g. side-conditions in the application of rules in Modal Logics, and substructural rules, as in  <em>non-commutative Linear Logic</em>. The idea of LF<sub><em>P</em></sub> is that  these conditions need only to be specified, while their <em>verification</em>  can be delegated to an external proof engine, in the style of the <em>Poincar&eacute; Principle</em>. We investigate and characterize the metatheoretical properties of the calculus underpinning LF<sub><em>P</em></sub>: strong normalization, confluence, and subject reduction. This latter property holds under the assumption that the predicates are <em>well-behaved</em>, i.e. <em>closed under weakening, permutation</em>, <em>substitution</em>, and <em>reduction</em> in the arguments.</p>
	      </a>

	      <a name="Cervesato">
		<h2>Trace Matching in a Concurrent Logical Framework.</h2>
		<h3><a href="http://www.qatar.cmu.edu/~iliano">Iliano Cervesato</a>, <a href="http://www.cs.cmu.edu/~fp/">Frank Pfenning</a>, <a href="http://www.qatar.cmu.edu/~sacchini/">Jorge Luis Sacchini</a>, <a href="http://www.itu.dk/~carsten/">Carsten Schürmann</a> and <a href="http://www.cs.cmu.edu/~rjsimmon/">Robert J. Simmons</a></h3>

		<p>Matching and unification play an important role in implementations of proof assistants, logical frameworks, and logic programming languages.  In particular, matching is at the heart of many reasoning tasks and underlies the operational semantic for well-moded logic programs. In this paper, we study the problem of matching on concurrent traces in the CLF logical framework, an extension of LF that supports the specification of concurrent and distributed systems. A concurrent trace is a sequence of computations where independent steps can be permuted. We give a sound and complete algorithm for matching traces with one variable standing for an unknown subtrace. Extending the result to general traces and to unification is left to future work.</p>

		<p><a href="http://www.qatar.cmu.edu/iliano/projects/metaCLF/">Project page</a></p>
	      </a>
            </ul>
          </div>
        </div>

      </div>
    </div>
  </body>
</html>
